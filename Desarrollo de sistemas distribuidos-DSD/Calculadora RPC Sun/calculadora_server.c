/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "calculadora.h"
#include "math.h"
double *
sumar_1_svc(operandoBasico arg1, struct svc_req *rqstp)
{
	static double result;
	//xdr_free(xdr_double, &result);
	result = arg1.a + arg1.b;

	return &result;
}

double *
restar_1_svc(operandoBasico arg1, struct svc_req *rqstp)
{
	static double result;
	//xdr_free(xdr_double, &result);
	result = arg1.a - arg1.b;

	return &result;
}

double *
division_1_svc(operandoBasico arg1, struct svc_req *rqstp)
{
	static double result;
	//xdr_free(xdr_double, &result);
	result = arg1.a / arg1.b;

	return &result;
}

double *
multiplicar_1_svc(operandoBasico arg1, struct svc_req *rqstp)
{
	static double result;
	//xdr_free(xdr_double, &result);
	result = arg1.a * arg1.b;

	return &result;
}

void EliminarNumero(Num num, int indice)
{
	for (int i = indice; i < num.numeros.numeros_len; i++)
	{
		num.numeros.numeros_val[i] = num.numeros.numeros_val[i + 1];
	}

	num.numeros.numeros_len--;
}

void EliminarOperando(Ope op, int indice)
{
	for (int i = indice; i < op.operandos.operandos_len; i++)
	{
		op.operandos.operandos_val[i] = op.operandos.operandos_val[i + 1];
	}

	op.operandos.operandos_len--;
}

double *
combinada_2_svc(Num arg1, Ope arg2, struct svc_req *rqstp)
{
	static double result;
	//xdr_free(xdr_vec, &result);
	if (arg2.operandos.operandos_len == arg1.numeros.numeros_len)
	{
		EliminarOperando(arg2, 0);
		arg1.numeros.numeros_val[0] *= -1;
	}

	for (int i = 0; i < arg2.operandos.operandos_len; i++)
	{

		if (arg2.operandos.operandos_val[i] == 'x' || arg2.operandos.operandos_val[i] == '*')
		{

			arg1.numeros.numeros_val[i] = arg1.numeros.numeros_val[i] * arg1.numeros.numeros_val[i + 1];
			EliminarOperando(arg2, i);
			EliminarNumero(arg1, i + 1);
			i = -1;
		}
		else if (arg2.operandos.operandos_val[i] == '/')
		{
			arg1.numeros.numeros_val[i] = arg1.numeros.numeros_val[i] / arg1.numeros.numeros_val[i + 1];
			EliminarOperando(arg2, i);
			EliminarNumero(arg1, i + 1);
			i = -1;
		}
	}

	for (int i = 0; i < arg2.operandos.operandos_len; i++)
	{

		if (arg2.operandos.operandos_val[i] == '+')
		{

			arg1.numeros.numeros_val[i] = arg1.numeros.numeros_val[i] + arg1.numeros.numeros_val[i + 1];
			EliminarOperando(arg2, i);
			EliminarNumero(arg1, i + 1);
			i = -1;
		}
		else if (arg2.operandos.operandos_val[i] == '-')
		{
			arg1.numeros.numeros_val[i] = arg1.numeros.numeros_val[i] - arg1.numeros.numeros_val[i + 1];
			EliminarOperando(arg2, i);
			EliminarNumero(arg1, i + 1);
			i = -1;
		}
	}

	result = arg1.numeros.numeros_val[0];

	return &result;
}

vec *sumavector_3_svc(vec arg1, vec arg2, struct svc_req *rqstp)
{
	static vec result;
	//xdr_free(xdr_vec, &result);
	result.v.v_len = arg1.v.v_len;
	result.v.v_val = (double *)malloc(result.v.v_len * sizeof(double));

	for (int i = 0; i < arg1.v.v_len; i++)
	{
		result.v.v_val[i] = arg1.v.v_val[i] + arg2.v.v_val[i];
	}

	return &result;
}

vec *restavector_3_svc(vec arg1, vec arg2, struct svc_req *rqstp)
{
	static vec result;
	//xdr_free(xdr_vec, &result);
	result.v.v_val = (double *)malloc(arg1.v.v_len * sizeof(double));

	for (int i = 0; i < arg1.v.v_len; i++)
	{
		result.v.v_val[i] = arg1.v.v_val[i] - arg2.v.v_val[i];
		result.v.v_len++;
	}

	return &result;
}

vec *multiplicarvector_3_svc(vec arg1, vec arg2, struct svc_req *rqstp)
{
	static vec result;
	//xdr_free(xdr_vec, &result);
	result.v.v_val = (double *)malloc(arg1.v.v_len * sizeof(double));

	for (int i = 0; i < arg1.v.v_len; i++)
	{
		result.v.v_val[i] = arg1.v.v_val[i] * arg2.v.v_val[i];
		result.v.v_len++;
	}

	return &result;
}

vec *dividirvector_3_svc(vec arg1, vec arg2, struct svc_req *rqstp)
{
	static vec result;
	//xdr_free(xdr_vec, &result);
	result.v.v_val = (double *)malloc(arg1.v.v_len * sizeof(double));

	for (int i = 0; i < arg1.v.v_len; i++)
	{
		result.v.v_val[i] = arg1.v.v_val[i] / arg2.v.v_val[i];
		result.v.v_len++;
	}

	return &result;
}

double *
escalar_3_svc(vec arg1, vec arg2, struct svc_req *rqstp)
{
	static double result;
	//xdr_free(xdr_double, (char *)result);
	
	result=0;
	for (int i = 0; i < arg1.v.v_len; i++)
	{
		result += (arg1.v.v_val[i] * arg2.v.v_val[i]);
	}

	return &result;
}

vec *ecuacioncuadratica_4_svc(double arg1, double arg2, double arg3, struct svc_req *rqstp)
{
	static vec result;
	//xdr_free(xdr_double, &result);
	result.v.v_len=2;
	result.v.v_val=(double *)malloc(result.v.v_len * sizeof(double));

	double raiz=(arg2*arg2) - (4*arg1*arg3);

	
	if(raiz>0)
	{
	result.v.v_val[0]=(-arg2+sqrt(raiz))/(2*arg1);
	result.v.v_val[1]=(-arg2-sqrt(raiz))/(2*arg1);
	}
	else{
		result.v.v_val[0]=-arg2/(2*arg1);
		result.v.v_val[1]=result.v.v_val[0];
	}
	
	return &result;
}
